#import required libraries
from PIL import Image, ImageTk  #for image processing and display
import tkinter as tk  #for GUI
from tkinter import filedialog  #for file selection dialog

class SteganographyApp:
    def __init__(self):
        """Initialize the main application window and variables"""
        self.image_path = ""  #Path to the original image
        self.secret_message = ""  #message to hide
        self.original_image = None  #PIL Image object for original
        self.modified_image = None  #PIL Image object with hidden data
        
        #create main window
        self.root = tk.Tk()
        self.root.title("Steganography Tool")
        self.root.geometry("800x700")  #set window size
        
        #set up all GUI components
        self.setup_ui()
        
    def setup_ui(self):
        """Create and arrange all GUI components"""
        #top frame for input controls
        top_frame = tk.Frame(self.root)
        top_frame.pack(pady=10)
        
        #secret message input
        tk.Label(top_frame, text="Secret Message:").grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.message_entry = tk.Entry(top_frame, width=50)
        self.message_entry.grid(row=0, column=1, padx=5, pady=5)
        
        #image path input with browse button
        tk.Label(top_frame, text="Image Path:").grid(row=1, column=0, padx=5, pady=5, sticky="e")
        self.image_entry = tk.Entry(top_frame, width=50)
        self.image_entry.grid(row=1, column=1, padx=5, pady=5)
        
        #button to open file dialog for image selection
        browse_button = tk.Button(top_frame, text="Browse", command=self.browse_image)
        browse_button.grid(row=1, column=2, padx=5, pady=5)
        
        #frame for action buttons
        button_frame = tk.Frame(self.root)
        button_frame.pack(pady=10)
        
        #main action buttons (load, hide, extract)
        tk.Button(button_frame, text="Load Image", command=self.load_image).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Hide Data", command=self.hide_data).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Extract Data", command=self.extract_data).pack(side=tk.LEFT, padx=5)
        
        #label for operation feedback
        self.status_label = tk.Label(self.root, text="Ready", fg="blue")
        self.status_label.pack(pady=5)
        
        #frame for image display (original and modified)
        images_frame = tk.Frame(self.root)
        images_frame.pack(pady=10)
        
        #original image display components
        self.original_label = tk.Label(images_frame, text="Original Image")
        self.original_label.grid(row=0, column=0, padx=10)
        self.original_image_label = tk.Label(images_frame)  #will hold the image
        self.original_image_label.grid(row=1, column=0, padx=10)
        
        #modified image display components
        self.modified_label = tk.Label(images_frame, text="Modified Image")
        self.modified_label.grid(row=0, column=1, padx=10)
        self.modified_image_label = tk.Label(images_frame)  #will hold the image
        self.modified_image_label.grid(row=1, column=1, padx=10)
        
        #output label for extracted messages
        self.output_label = tk.Label(self.root, text="", wraplength=700)
        self.output_label.pack(pady=10)
    
    def browse_image(self):
        """Open file dialog to select a BMP image"""
        file_path = filedialog.askopenfilename(filetypes=[("BMP files", "*.bmp")])
        if file_path:
            self.image_entry.delete(0, tk.END)  #clear current entry
            self.image_entry.insert(0, file_path)  #add new path
    
    def load_image(self):
        """Load the selected image and display it"""
        self.image_path = self.image_entry.get()
        if not self.image_path:
            self.status_label.config(text="Please select an image first", fg="red")
            return
            
        try:
            #open the image file
            self.original_image = Image.open(self.image_path)
            
            #create a display version (resize if too large)
            if self.original_image.width > 300 or self.original_image.height > 300:
                display_image = self.original_image.copy()
                display_image.thumbnail((300, 300))  #maintain aspect ratio
                img = ImageTk.PhotoImage(display_image)
            else:
                img = ImageTk.PhotoImage(self.original_image)
            
            #update the display
            self.original_image_label.config(image=img)
            self.original_image_label.image = img  #keep reference to prevent garbage collection
            
            #clear any previous modified image
            self.modified_image_label.config(image='')
            self.modified_image_label.image = None
            
            self.status_label.config(text=f"Image loaded: {self.image_path}", fg="green")
        except Exception as e:
            self.status_label.config(text=f"Error loading image: {str(e)}", fg="red")
    
    def hide_data(self):
        """Hide the secret message in the image using LSB steganography"""
        if not hasattr(self, 'original_image') or not self.original_image:
            self.status_label.config(text="Please load an image first", fg="red")
            return
            
        self.secret_message = self.message_entry.get()
        if not self.secret_message:
            self.status_label.config(text="Please enter a message", fg="red")
            return
            
        try:
            #convert text to binary string (8 bits per character)
            binary_text = ''.join(format(ord(char), '08b') for char in self.secret_message)
            binary_text += "00000000"  #add null terminator to mark end
            
            #get all pixel values from image
            pixels = list(self.original_image.getdata())
            
            #verify message fits in image
            if len(binary_text) > len(pixels):
                self.status_label.config(text="Message too long for image", fg="red")
                return
            
            #modify each pixel's LSB to store message bits
            new_pixels = []
            for i, pixel in enumerate(pixels):
                if i < len(binary_text):
                    #clear LSB (bitwise AND with 11111110) then set to message bit
                    new_pixel = (pixel & 0b11111110) | int(binary_text[i])
                    new_pixels.append(new_pixel)
                else:
                    new_pixels.append(pixel)  #leave remaining pixels unchanged
            
            #create new image with modified pixels
            self.modified_image = Image.new("L", self.original_image.size)
            self.modified_image.putdata(new_pixels)
            output_file = "hidden_data.bmp"
            self.modified_image.save(output_file)
            
            #display the modified image
            if self.modified_image.width > 300 or self.modified_image.height > 300:
                display_image = self.modified_image.copy()
                display_image.thumbnail((300, 300))
                img = ImageTk.PhotoImage(display_image)
            else:
                img = ImageTk.PhotoImage(self.modified_image)
            
            self.modified_image_label.config(image=img)
            self.modified_image_label.image = img  #keep reference
            
            self.status_label.config(text=f"Data hidden successfully in {output_file}", fg="green")
        except Exception as e:
            self.status_label.config(text=f"Error: {str(e)}", fg="red")
    
    def extract_data(self):
        """Extract hidden message from the modified image"""
        if not hasattr(self, 'modified_image') or not self.modified_image:
            self.status_label.config(text="Please hide data first", fg="red")
            return
            
        try:
            #get all pixel values from modified image
            pixels = list(self.modified_image.getdata())
            
            #extract LSB from each pixel
            binary_text = ''.join(str(pixel & 0b00000001) for pixel in pixels)
            
            #split binary string into 8-bit chunks (bytes)
            chars = [binary_text[i:i+8] for i in range(0, len(binary_text), 8)]
            
            #reconstruct message until null terminator
            recovered_text = ''
            for char in chars:
                if char == '00000000':  #stop at null terminator
                    break
                recovered_text += chr(int(char, 2))  #convert binary t o character
            
            #display extracted message
            self.output_label.config(text=f"Recovered Text: {recovered_text}")
            self.status_label.config(text="Data extracted successfully", fg="green")
        except Exception as e:
            self.status_label.config(text=f"Error: {str(e)}", fg="red")
    
    def run(self):
        """Start the application"""
        self.root.mainloop()

#entry point - create and run the application
if __name__ == "__main__":
    app = SteganographyApp()
    app.run()
